name: CI with RDP via Ngrok

on: [push, workflow_dispatch]

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout code (gerekliyse)
        uses: actions/checkout@v3

      - name: Enable RDP Access
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
          # Runner kullanıcısının şifresini ayarla
          $password = "P@ssw0rdRDP123!" # Daha güvenli veya rastgele bir şifre kullanabilirsiniz
          $user = "runneradmin"
          Add-Type -AssemblyName System.Web
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          Set-LocalUser -Name $user -Password $securePassword
          echo "RDP User: $user"
          echo "RDP Password: $password"
          
      - name: Download and setup Ngrok
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        run: |
          # Ngrok'u indir ve çıkar
          Invoke-WebRequest https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok.zip
          Expand-Archive ngrok.zip -DestinationPath .
          # Ngrok auth token'ını ayarla
          .\ngrok.exe authtoken $Env:NGROK_AUTH_TOKEN
          # Ngrok'u arka planda başlat ve log dosyasını belirt
          # Bu, hem ngrok'un çalışmasını sağlar hem de API'sinin aktif olmasını garantiler.
          Start-Process -FilePath ".\ngrok.exe" -ArgumentList "tcp 3389 --log=stdout" -NoNewWindow -PassThru

      - name: Wait for Ngrok API to be ready
        run: Start-Sleep -s 5 # Ngrok'un başlaması için kısa bir bekleme süresi

      - name: Get Ngrok Tunnel Public URL
        id: ngrok_tunnel # Bu adıma bir ID veriyoruz ki çıktısını başka adımlarda kullanabilelim
        run: |
          # Ngrok'un yerel API'sine istek atarak tünel bilgilerini JSON olarak al
          $tunnels = Invoke-RestMethod -Method Get -Uri "http://127.0.0.1:4040/api/tunnels"
          # TCP tünelinin public URL'sini seç
          $tcp_tunnel_url = ($tunnels.tunnels | Where-Object {$_.proto -eq "tcp"}).public_url
          if ($tcp_tunnel_url) {
            echo "Ngrok tunnel URL: $tcp_tunnel_url"
            # Bu URL'yi bir sonraki adımda kullanmak için bir çıktı değişkenine ata
            echo "::set-output name=url::$tcp_tunnel_url"
          } else {
            echo "Ngrok TCP tüneli bulunamadı!"
            exit 1
          }

      - name: Print Connection Info
        run: |
          echo "=========================================================================="
          echo "RDP BAĞLANTI BİLGİLERİ"
          echo "=========================================================================="
          echo "Adres (Host): ${{ steps.ngrok_tunnel.outputs.url }}"
          echo "Kullanıcı Adı (Username): runneradmin"
          echo "Şifre (Password): P@ssw0rdRDP123!" # Şifreyi burada tekrar yazdırıyoruz
          echo "=========================================================================="
          echo "Bu bilgilerle bir RDP istemcisi kullanarak bağlanabilirsiniz."
          echo "Workflow, siz manuel olarak durdurana kadar açık kalacaktır."
          echo "=========================================================================="
          
      - name: Keep Tunnel Alive
        # Bu adım, workflow'un hemen bitmesini engeller.
        # GitHub Actions, bir iş için maksimum 6 saatlik bir zaman aşımına sahiptir.
        run: |
          echo "Tünel aktif. Kapatmak için GitHub Actions arayüzünden 'Cancel workflow' seçeneğini kullanın."
          Start-Sleep -s 21000 # Yaklaşık 5.8 saat bekler.
